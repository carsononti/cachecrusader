<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport"content="width=device-width,initial-scale=1,viewport-fit=cover"/>
    <meta name="format-detection" content="telephone=no">
    <title>Cache Crusader</title>
    <style>
        :root {
            --pad: 14px;
            --btn: 64px;
            --safe-left: env(safe-area-inset-left, 0px);
            --safe-right: env(safe-area-inset-right, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
        }

        html, body {
            margin: 0;
            height: 100%;
            background: #0b1b2b;
        }

        #game {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
        }

        #game canvas {
            image-rendering: pixelated;
        }

        .hud {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 10;
        }

        .controls {
            position: absolute;
            left: calc(var(--pad) + var(--safe-left));
            bottom: calc(var(--pad) + var(--safe-bottom));
            display: grid;
            grid-template-columns: var(--btn) var(--btn) var(--btn);
            grid-template-rows: var(--btn) var(--btn) var(--btn);
            gap: 8px;
            pointer-events: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
        }

        .controls button {
            pointer-events: auto;
            width: var(--btn);
            height: var(--btn);
            border-radius: 3px;          
            border: 3px solid #222;     
            background: #444;
            color: #fff;
            font: bold 20px monospace;
            text-shadow: 1px 1px 0 #000;
            image-rendering: pixelated;
            touch-action: none;
        }

        .controls button:active {
            background: #222;
            border-color: #ffcc00;
            color: #ffcc00;
        }

        .btn-up {
            grid-area: 1 / 2;
        }

        .btn-left {
            grid-area: 2 / 1;
        }

        .btn-down {
            grid-area: 3 / 2;
        }

        .btn-right {
            grid-area: 2 / 3;
        }

        .action-wrap {
            position: absolute;
            right: calc(var(--pad) + var(--safe-right));
            bottom: calc(var(--pad) + var(--safe-bottom));
            pointer-events: none;
            touch-action: none;
        }

        .action-wrap button {
            pointer-events: auto;
            width: calc(var(--btn) * 1.2);
            height: calc(var(--btn) * 1.2);
            border-radius: 3px;
            border: 3px solid #222;
            background: #800;
            color: #fff;
            font: bold 20px monospace;
            text-shadow: 1px 1px 0 #000;
            image-rendering: pixelated;
            touch-action: none;
        }

        .action-wrap button:active {
            background: #c00;
            border-color: #ffcc00;
            color: #ffcc00;
        }

        @media (max-width: 420px) {
            :root {
                --btn: 56px;
                --pad: 10px;
            }
        }

        /* iOS quirks fix */
        html, body, #game, #game canvas,
        .hud, .controls, .controls button,
        .action-wrap, .action-wrap button {
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }

        * {
            -webkit-tap-highlight-color: rgba(0,0,0,0);
        }

        canvas, img {
            -webkit-user-drag: none;
        }
    </style>
</head>
<body>
    <div id="game"></div>
    <div class="hud" aria-hidden="false">
        <div class="controls" id="dpad" role="group" aria-label="Movement">
            <button class="btn-up" data-dir="up" aria-label="Up">▲</button>
            <button class="btn-left" data-dir="left" aria-label="Left">◀</button>
            <button class="btn-down" data-dir="down" aria-label="Down">▼</button>
            <button class="btn-right" data-dir="right" aria-label="Right">▶</button>
        </div>
        <div class="action-wrap">
            <button id="btn-action" aria-label="Action">A</button>
        </div>
    </div>

    <script type="module">
        import kaboom from "https://cdn.jsdelivr.net/npm/kaboom@3000/dist/kaboom.mjs";

        kaboom({
            root: document.querySelector("#game"),
            width: 256,
            height: 256,
            background: [5, 5, 16],
            crisp: true,
            letterbox: true,
            stretch: false,
        });

        // Prevent text selection and context menu globally
        document.addEventListener("selectstart", (e) => e.preventDefault());
        document.addEventListener("contextmenu", (e) => e.preventDefault(), { passive: false });

        // Soft block double-tap zoom without killing pinch-zoom accessibility
        let lastTouch = 0;
        window.addEventListener("touchend", (e) => {
            const now = Date.now();
            if (now - lastTouch < 350) { e.preventDefault(); }
            lastTouch = now;
        }, { passive: false });

        // Load custom font
        loadBitmapFont("unscii", "unscii_8x8.png", 8, 8);

        // Sprites / Atlas 
        loadSpriteAtlas("dungeon.png", {
            "hero": {
                "x": 128, "y": 196, "width": 144, "height": 28, "sliceX": 9,
                "anims": {
                    "idle": { "from": 0, "to": 3, "speed": 5, "loop": true },
                    "run": { "from": 4, "to": 7, "speed": 10, "loop": true },
                    "hit": 8
                }
            },
            "ogre": {
                "x": 16, "y": 320, "width": 256, "height": 32, "sliceX": 8,
                "anims": {
                    "idle": { "from": 0, "to": 3, "speed": 3, "loop": true },
                    "run": { "from": 4, "to": 7, "speed": 10, "loop": true }
                }
            },
            "floor": { "x": 16, "y": 64, "width": 48, "height": 48, "sliceX": 3, "sliceY": 3 },
            "chest": {
                "x": 304, "y": 304, "width": 48, "height": 16, "sliceX": 3,
                "anims": {
                    "open": { "from": 0, "to": 2, "speed": 20, "loop": false },
                    "close": { "from": 2, "to": 0, "speed": 20, "loop": false }
                }
            },
            "lava_fountain": {
                "x": 64, "y": 0, "width": 48, "height": 48, "sliceX": 3,
                "anims": {
                    "flow": { "from": 0, "to": 2, "speed": 7, "loop": true }
                }
            },
            "door": {
                "x": 32, "y": 208, "width": 64, "height": 48, "sliceX": 2,
                "anims": {
                    "open": { "from": 0, "to": 1, "loop": false },
                    "close": { "from": 1, "to": 0, "loop": false }
                }
            },
            "health": {
                "x": 288, "y": 256, "width": 48, "height": 16, "sliceX": 3,
            },
            "wall": { "x": 16, "y": 16, "width": 16, "height": 16 },
            "wall_top": { "x": 16, "y": 0, "width": 16, "height": 16 },
            "wall_left": { "x": 16, "y": 128, "width": 16, "height": 16 },
            "wall_right": { "x": 0, "y": 128, "width": 16, "height": 16 },
            "wall_topleft": { "x": 32, "y": 128, "width": 16, "height": 16 },
            "wall_topright": { "x": 48, "y": 128, "width": 16, "height": 16 },
            "wall_botleft": { "x": 32, "y": 144, "width": 16, "height": 16 },
            "wall_botright": { "x": 48, "y": 144, "width": 16, "height": 16 }
        });

        // Levels 
        addLevel([
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
        ], {
            tileWidth: 16,
            tileHeight: 16,
            tiles: { " ": () => [sprite("floor", { frame: ~~rand(0, 8) })] },
        });

        const map = addLevel([
            "tt  ttt1tt",
            "cw  www wd",
            "l =      r",
            "l        r",
            "l        r",
            "l      $ r",
            "l        r",
            "l $      r",
            "atttt1  tb",
            "wwwww   ww",
            "      =   ",
        ], {
            tileWidth: 16,
            tileHeight: 16,
            tiles: {
                "=": () => DoorTile(false),
                "1": () => [sprite("lava_fountain", { anim: "flow" }), area({ shape: new Rect(vec2(0, 12), 16, 20) }), body({ isStatic: true }), tile({ isObstacle: true })],
                "$": () => [sprite("chest"), area(), body({ isStatic: true }), tile({ isObstacle: true }), { opened: false }, "chest"],
                "a": () => [sprite("wall_botleft"), area({ shape: new Rect(vec2(0), 4, 16) }), body({ isStatic: true }), tile({ isObstacle: true })],
                "b": () => [sprite("wall_botright"), area({ shape: new Rect(vec2(12, 0), 4, 16) }), body({ isStatic: true }), tile({ isObstacle: true })],
                "c": () => [sprite("wall_topleft"), area(), body({ isStatic: true }), tile({ isObstacle: true })],
                "d": () => [sprite("wall_topright"), area(), body({ isStatic: true }), tile({ isObstacle: true })],
                "w": () => [sprite("wall"), area(), body({ isStatic: true }), tile({ isObstacle: true })],
                "t": () => [sprite("wall_top"), area({ shape: new Rect(vec2(0, 12), 16, 4) }), body({ isStatic: true }), tile({ isObstacle: true })],
                "l": () => [sprite("wall_left"), area({ shape: new Rect(vec2(0), 4, 16) }), body({ isStatic: true }), tile({ isObstacle: true })],
                "r": () => [sprite("wall_right"), area({ shape: new Rect(vec2(12, 0), 4, 16) }), body({ isStatic: true }), tile({ isObstacle: true })],
            },
        });

        // Interaction
        function DoorTile(initialOpen = false) {
            return [
                sprite("door", { anim: initialOpen ? "open" : "close" }),
                anchor("botleft"),
                area(),
                body({ isStatic: true }),
                "door",
                {
                    opened: initialOpen,

                    add() {
                        this.setOpen(this.opened);

                        // run every frame
                        this.onUpdate(() => {
                            if (!player) return; // safety in case player isn't loaded yet
                            if (player.pos.y + 16 < this.pos.y) {
                                this.z = 1000;   // player below → door under
                            }
                            else {
                                this.z = -1000;    // player above → door over
                            }
                        });
                    },

                    setOpen(state) {
                        this.opened = state;
                        this.play(state ? "open" : "close");
                        this.area.shape = state
                            ? new Rect(vec2(0, 0), 1, 1)     // passable
                            : new Rect(vec2(0, -1), 32, 16);  // solid
                    },
                },
            ];
        }

        function interact() {
            for (const col of player.getCollisions()) {
                const c = col.target;
                if (c.is("chest")) {
                    if (c.opened) { c.play("close"); c.opened = false; }
                    else { c.play("open"); c.opened = true; }
                }

                if (c.is && c.is("door")) {
                    c.setOpen(!c.opened);
                }
            }
        }

        // Players and mobs 
        const player = map.spawn([
            sprite("hero", { anim: "idle" }),
            area({ shape: new Rect(vec2(0, 6), 12, 12) }),
            body(),
            anchor("center"),
            tile(),
            z(5)
        ], 2, 2);

        const ogre = map.spawn([
            sprite("ogre"),
            anchor("bot"),
            area({ scale: 0.5 }),
            body({ isStatic: false }),
            tile({ isObstacle: false }),
            z(10)
        ], 5, 8);

        ogre.add([
            text("Muggle", {
                size: 8,
                font: "unscii"
            }),
            anchor("bot"),
            pos(0, -30),
        ]);

        // Player health
        // Config
        const MAX_HEALTH = 6; // 3 full hearts
        let currentHealth = 6; // start full

        // Create heart icons
        const healthIcons = [];
        const HEART_SIZE = 16;

        for (let i = 0; i < MAX_HEALTH / 2; i++) {
            const heart = add([
                sprite("health", { frame: 0 }), // full by default
                pos(4 + i * (HEART_SIZE + 2), 4), // spacing
                fixed(),
                z(1000),
            ]);
            healthIcons.push(heart);
        }

        // Function to update the display
        function updateHearts() {
            for (let i = 0; i < healthIcons.length; i++) {
                const heartValue = currentHealth - i * 2;
                if (heartValue >= 2) {
                    healthIcons[i].frame = 0; // full
                } else if (heartValue === 1) {
                    healthIcons[i].frame = 1; // half
                } else {
                    healthIcons[i].frame = 2; // empty
                }
            }
        }

        // Example: lose health on action button press
        onKeyPress("h", () => {
            if (currentHealth > 0) {
                currentHealth--;
                updateHearts();
            }
        });

        // Example: restore on "j"
        onKeyPress("j", () => {
            if (currentHealth < MAX_HEALTH) {
                currentHealth++;
                updateHearts();
            }
        });

        // Initialize once
        updateHearts();


        // Touch controls
        const pressed = new Set();
        const dirVec = () => {
            let x = 0, y = 0;
            if (pressed.has("left")) x -= 1;
            if (pressed.has("right")) x += 1;
            if (pressed.has("up")) y -= 1;
            if (pressed.has("down")) y += 1;
            const v = vec2(x, y);
            return v.len() > 0 ? v.unit() : v;
        };

        const startPress = (d) => {
            pressed.add(d);
            const v = dirVec();
            if (v.x < 0) player.flipX = true;
            if (v.x > 0) player.flipX = false;
            if (player.curAnim() !== "run" && (v.x || v.y)) player.play("run");
        };

        const stopPress = (d) => {
            pressed.delete(d);
            const v = dirVec();
            if (!v.x && !v.y && player.curAnim() !== "idle") player.play("idle");
            if (v.x < 0) player.flipX = true;
            if (v.x > 0) player.flipX = false;
        };

        onUpdate(() => {
            const v = dirVec();
            player.move(v.scale(120));
            camPos(player.pos);
            if (!v.x && !v.y && player.curAnim() !== "idle") player.play("idle");
            else if ((v.x || v.y) && player.curAnim() !== "run") player.play("run");
        });

        player.onPhysicsResolve(() => camPos(player.pos));

        const dpad = document.getElementById("dpad");
        const actionBtn = document.getElementById("btn-action");

        const bindHold = (el, dir) => {
            const down = (e) => { e.preventDefault(); startPress(dir); el.setPointerCapture?.(e.pointerId); };
            const up = (e) => { e.preventDefault(); stopPress(dir); el.releasePointerCapture?.(e.pointerId); };
            el.addEventListener("pointerdown", down, { passive: false });
            el.addEventListener("pointerup", up, { passive: false });
            el.addEventListener("pointercancel", up, { passive: false });
            el.addEventListener("pointerleave", up, { passive: false });
        };

        dpad.querySelectorAll("button[data-dir]").forEach(btn => bindHold(btn, btn.dataset.dir));
        actionBtn.addEventListener("pointerdown", (e) => { e.preventDefault(); actionBtn.setPointerCapture?.(e.pointerId); interact(); });
        actionBtn.addEventListener("pointerup", (e) => { e.preventDefault(); actionBtn.releasePointerCapture?.(e.pointerId); });
    </script>
</body>
</html>
