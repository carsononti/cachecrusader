<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport"content="width=device-width,initial-scale=1,viewport-fit=cover"/>
    <meta name="format-detection" content="telephone=no">
    <title>Cache Crusader</title>
    <style>
        :root {
            --pad: 14px;
            --btn: 64px;
            --safe-left: env(safe-area-inset-left, 0px);
            --safe-right: env(safe-area-inset-right, 0px);
            --safe-bottom: env(safe-area-inset-bottom, 0px);
        }

        html, body {
            margin: 0;
            height: 100%;
            background: #0b1b2b;
        }

        #game {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
        }

        #game canvas {
            image-rendering: pixelated;
        }

        .hud {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 10;
        }

        /* iOS quirks fix */
        html, body, #game, #game canvas,
        .hud, .controls, .controls button,
        .action-wrap, .action-wrap button {
            -webkit-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
        }

        * {
            -webkit-tap-highlight-color: rgba(0,0,0,0);
        }

        canvas, img {
            -webkit-user-drag: none;
        }
    </style>
</head>
<body>
    <div id="game"></div>
    <div class="hud" aria-hidden="false">
    </div>

    <script type="module">
        import kaboom from "https://cdn.jsdelivr.net/npm/kaboom@3000/dist/kaboom.mjs";

        // Initialize game instance
        kaboom({
            root: document.querySelector("#game"),
            width: 256,
            height: 256,
            background: [5, 5, 16],
            crisp: true,
            letterbox: true,
            stretch: false,
        });

        // Prevent text selection and context menu globally
        document.addEventListener("selectstart", (e) => e.preventDefault());
        document.addEventListener("contextmenu", (e) => e.preventDefault(), { passive: false });

        // Soft block double-tap zoom without killing pinch-zoom accessibility
        let lastTouch = 0;
        window.addEventListener("touchend", (e) => {
            const now = Date.now();
            if (now - lastTouch < 350) { e.preventDefault(); }
            lastTouch = now;
        }, { passive: false });

        // Load custom font
        loadBitmapFont("unscii", "unscii_8x8.png", 8, 8);

        // Sprite atlas
        loadSpriteAtlas("dungeon.png", {
            "hero": {
                "x": 128, "y": 196, "width": 144, "height": 28, "sliceX": 9,
                "anims": {
                    "idle": { "from": 0, "to": 3, "speed": 5, "loop": true },
                    "run": { "from": 4, "to": 7, "speed": 10, "loop": true },
                    "hit": 8
                }
            },
            "ogre": {
                "x": 16, "y": 320, "width": 256, "height": 32, "sliceX": 8,
                "anims": {
                    "idle": { "from": 0, "to": 3, "speed": 3, "loop": true },
                    "run": { "from": 4, "to": 7, "speed": 10, "loop": true }
                }
            },
            "chest": {
                "x": 304, "y": 304, "width": 48, "height": 16, "sliceX": 3,
                "anims": {
                    "open": { "from": 0, "to": 2, "speed": 20, "loop": false },
                    "close": { "from": 2, "to": 0, "speed": 20, "loop": false }
                }
            },
            "lava_fountain": {
                "x": 64, "y": 0, "width": 48, "height": 48, "sliceX": 3,
                "anims": {
                    "flow": { "from": 0, "to": 2, "speed": 7, "loop": true }
                }
            },
            "door": {
                "x": 32, "y": 208, "width": 64, "height": 48, "sliceX": 2,
                "anims": {
                    "open": { "from": 0, "to": 1, "loop": false },
                    "close": { "from": 1, "to": 0, "loop": false }
                }
            },
            "health": { "x": 288, "y": 256, "width": 48, "height": 16, "sliceX": 3 },
            "arrow_button": { "x": 288, "y": 336, "width": 64, "height": 16, "sliceX": 4 },
            "arrow_button_action": { "x": 288, "y": 352, "width": 64, "height": 16, "sliceX": 4 },
            "interact_button": { "x": 288, "y": 368, "width": 32, "height": 16, "sliceX": 2 },
            "floor": { "x": 16, "y": 64, "width": 48, "height": 48, "sliceX": 3, "sliceY": 3 },
            "wall": { "x": 16, "y": 16, "width": 16, "height": 16 },
            "wall_top": { "x": 16, "y": 0, "width": 16, "height": 16 },
            "wall_left": { "x": 16, "y": 128, "width": 16, "height": 16 },
            "wall_right": { "x": 0, "y": 128, "width": 16, "height": 16 },
            "wall_topleft": { "x": 32, "y": 128, "width": 16, "height": 16 },
            "wall_topright": { "x": 48, "y": 128, "width": 16, "height": 16 },
            "wall_botleft": { "x": 32, "y": 144, "width": 16, "height": 16 },
            "wall_botright": { "x": 48, "y": 144, "width": 16, "height": 16 }
        });

        // Floor map 
        addLevel([
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
            "          ",
        ], {
            tileWidth: 16,
            tileHeight: 16,
            tiles: { " ": () => [sprite("floor", { frame: ~~rand(0, 8) })] },
        });

        // Level map
        const map = addLevel([
            "tt  ttt1tt",
            "cw  www wd",
            "l =      r",
            "l        r",
            "l        r",
            "l      $ r",
            "l        r",
            "l $      r",
            "atttt1  tb",
            "wwwww   ww",
            "      =   ",
        ], {
            tileWidth: 16,
            tileHeight: 16,
            tiles: {
                "=": () => DoorTile(false),
                "1": () => [sprite("lava_fountain", { anim: "flow" }), area({ shape: new Rect(vec2(0, 12), 16, 20) }), body({ isStatic: true }), tile({ isObstacle: true })],
                "$": () => [sprite("chest"), area(), body({ isStatic: true }), tile({ isObstacle: true }), { opened: false }, "chest"],
                "a": () => [sprite("wall_botleft"), area({ shape: new Rect(vec2(0), 4, 16) }), body({ isStatic: true }), tile({ isObstacle: true })],
                "b": () => [sprite("wall_botright"), area({ shape: new Rect(vec2(12, 0), 4, 16) }), body({ isStatic: true }), tile({ isObstacle: true })],
                "c": () => [sprite("wall_topleft"), area(), body({ isStatic: true }), tile({ isObstacle: true })],
                "d": () => [sprite("wall_topright"), area(), body({ isStatic: true }), tile({ isObstacle: true })],
                "w": () => [sprite("wall"), area(), body({ isStatic: true }), tile({ isObstacle: true })],
                "t": () => [sprite("wall_top"), area({ shape: new Rect(vec2(0, 12), 16, 4) }), body({ isStatic: true }), tile({ isObstacle: true })],
                "l": () => [sprite("wall_left"), area({ shape: new Rect(vec2(0), 4, 16) }), body({ isStatic: true }), tile({ isObstacle: true })],
                "r": () => [sprite("wall_right"), area({ shape: new Rect(vec2(12, 0), 4, 16) }), body({ isStatic: true }), tile({ isObstacle: true })],
            },
        });

        // Door logic
        function DoorTile(initialOpen = false) {
            return [
                sprite("door", { anim: initialOpen ? "open" : "close" }),
                anchor("botleft"),
                area(),
                body({ isStatic: true }),
                "door",
                {
                    opened: initialOpen,

                    add() {
                        this.setOpen(this.opened);
                        this.onUpdate(() => {
                            if (!player) return; // Safety in case player isn't loaded yet
                            if (player.pos.y + 16 < this.pos.y) {
                                this.z = 1000; // Player below -> door above
                            }
                            else {
                                this.z = -1000; // player above -> door below
                            }
                        });
                    },

                    setOpen(state) {
                        this.opened = state;
                        this.play(state ? "open" : "close");
                        this.area.shape = state
                            ? new Rect(vec2(0, 0), 1, 1) // Passable
                            : new Rect(vec2(0, -1), 32, 16); // Solid
                    },
                },
            ];
        }

        function interact() {
            for (const col of player.getCollisions()) {
                const c = col.target;
                if (c.is("chest")) {
                    if (c.opened) { c.play("close"); c.opened = false; }
                    else { c.play("open"); c.opened = true; }
                }

                if (c.is && c.is("door")) {
                    c.setOpen(!c.opened);
                }
            }
        }

        // Players and mobs 
        const player = map.spawn([
            sprite("hero", { anim: "idle" }),
            area({ shape: new Rect(vec2(0, 6), 12, 12) }),
            body(),
            anchor("center"),
            tile(),
            z(5)
        ], 2, 2);

        const ogre = map.spawn([
            sprite("ogre"),
            anchor("bot"),
            area({ scale: 0.5 }),
            body({ isStatic: false }),
            tile({ isObstacle: false }),
            z(10)
        ], 5, 8);

        ogre.add([
            text("Muggle", {
                size: 8,
                font: "unscii"
            }),
            anchor("bot"),
            pos(0, -30),
        ]);

        // Player health
        const MAX_HEALTH = 6;
        let currentHealth = 6;
        const healthIcons = [];
        const HEART_SIZE = 16;

        // Create heart icons
        for (let i = 0; i < MAX_HEALTH / 2; i++) {
            const heart = add([
                sprite("health", { frame: 0 }), // Full by default
                pos(4 + i * (HEART_SIZE + 2), 4), // Spacing
                fixed(),
                z(1000) // Always on top
            ]);
            healthIcons.push(heart);
        }

        // Display health icons
        function updateHearts() {
            for (let i = 0; i < healthIcons.length; i++) {
                const heartValue = currentHealth - i * 2;
                if (heartValue >= 2) {
                    healthIcons[i].frame = 0; // Full
                } else if (heartValue === 1) {
                    healthIcons[i].frame = 1; // Half
                } else {
                    healthIcons[i].frame = 2; // Empty
                }
            }
        }
        updateHearts();

        // TODO: debug lose health on "h"
        onKeyPress("h", () => {
            if (currentHealth > 0) {
                currentHealth--;
                updateHearts();
            }
        });

        // TODO: debug health restore on "j"
        onKeyPress("j", () => {
            if (currentHealth < MAX_HEALTH) {
                currentHealth++;
                updateHearts();
            }
        });

        onKeyPress("space", interact);
  
        const up_btn = add([text("▲"), scale(0.8), pos(32, 200), anchor("center"), fixed(), area()]);
        const down_btn = add([text("▼"), scale(0.8), pos(32, 240), anchor("center"), fixed(), area()]);
        const left_btn = add([text("◀"), scale(0.6), pos(11, 221), anchor("center"), fixed(), area()]);
        const right_btn = add([text("▶"), scale(0.6), pos(52, 221), anchor("center"), fixed(), area()]);

        const interact_btn = add([text("x"), scale(1.2), pos(220, 221), anchor("center"), fixed(), area()]);

        // ---- Interact button (sprite) ----
        const SCL = 3;
        const interactPos = vec2(width() - 22 * SCL, height() - 22 * SCL);

        const interactBtn = add([
            sprite("interact_button", { frame: 0 }), // 0 idle, 1 pressed in your atlas
            pos(interactPos),
            scale(SCL),
            fixed(),
            area(),
            z(10_000),
            { canUse: false },
        ]);

        // Press visual + call your interact()
        function setInteractDown(isDown) {
            interactBtn.frame = isDown ? 1 : 0;
            // tiny “press” nudge
            interactBtn.pos = interactPos.add(vec2(0, isDown ? 1 : 0));
        }

        interactBtn.onClick(() => {
            setInteractDown(true);
            interact();              // your existing interact logic
            wait(0.08, () => setInteractDown(false));
        });

        // Context awareness: pulse when something is in range
        onUpdate(() => {
            // player near an interactable?
            const near = player.getCollisions()
                .some(c => c.target.is?.("door") || c.target.is?.("chest"));

            interactBtn.canUse = near;

            // dim when not usable, pulse when usable
            const base = SCL;
            const pulse = base * (1 + (near ? 0.03 * Math.sin(time() * 8) : 0));
            interactBtn.scale = vec2(pulse);

            interactBtn.color = near ? rgb(255, 255, 255) : rgb(180, 180, 180);
        });


        // --- hold state (mouse + touch unified by Kaboom) ---
        let pointerHeld = false;
        onMouseDown(() => { pointerHeld = true; });
        onMouseRelease(() => { pointerHeld = false; });

        // which directions are currently held
        const held = new Set();

        // helper to wire a button to a direction
        function bindHold(btn, dir) {
            btn.onHoverUpdate(() => {
                setCursor("pointer");
                if (pointerHeld) {
                    held.add(dir);
                    btn.color = rgb(255, 255, 0);
                }
            });
            btn.onHoverEnd(() => {
                held.delete(dir);
                btn.color = rgb(255, 255, 255);
            });
            onMouseRelease(() => {
                held.delete(dir);
                btn.color = rgb(255, 255, 255);
            });
        }
        bindHold(up_btn, "up");
        bindHold(down_btn, "down");
        bindHold(left_btn, "left");
        bindHold(right_btn, "right");
        bindHold(interact_btn, "interact");

        // safety: releasing anywhere clears all holds
        function releaseAll() { held.clear(); }
        window.addEventListener("blur", releaseAll, { passive: true });
        onMouseRelease(releaseAll);

        const SPEED = 120
        onUpdate(() => {
            let x = 0, y = 0;

            // buttons
            if (held.has("left")) x -= 1;
            if (held.has("right")) x += 1;
            if (held.has("up")) y -= 1;
            if (held.has("down")) y += 1;

            // keyboard (WASD)
            if (isKeyDown("a")) x -= 1;
            if (isKeyDown("d")) x += 1;
            if (isKeyDown("w")) y -= 1;
            if (isKeyDown("s")) y += 1;

            const v = vec2(x, y);
            if (v.len() > 0) {
                const u = v.unit();
                if (u.x < 0) player.flipX = true;
                if (u.x > 0) player.flipX = false;
                player.move(u.scale(SPEED));
                if (player.curAnim() !== "run") player.play("run");
            } else if (player.curAnim() !== "idle") {
                player.play("idle");
            }

            camPos(player.pos);
        });

        player.onPhysicsResolve(() => camPos(player.pos));

        ;["a", "d", "w", "s"].forEach((key) => {
            onKeyPress(key, () => {
                player.play("run")
            })
            onKeyRelease(key, () => {
                if (
                    !isKeyDown("a")
                    && !isKeyDown("d")
                    && !isKeyDown("w")
                    && !isKeyDown("s")
                ) {
                    player.play("idle")
                }
            })
        })
    </script>
</body>
</html>
